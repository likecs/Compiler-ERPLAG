/*
 *	COMPILER PROJECT- ERPLAG COMPILER
 *	Batch Number 74
 *	Bhuvnesh Jain : 2014A7PS028P
 *	Chirag Agarwal : 2014A7PS033P
 */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include "lexerDef.h"
#include "lexer.h"
#include "parserDef.h"
#include "parser.h"
#include "symbolDef.h"
#include "symbolTable.h"
#include "astDef.h"
#include "ast.h"

#define LIMIT 		25

void printSep();

int main(int argc, char * argv[])
{
	//Initialise the hash table for keywords
	hashTable table = initializeHashTable(hash_capacity);
	FILE *fp = fopen("keywords.txt", "r");
	int type, option;	
	char input[21];
	while(~fscanf(fp, "%d %s", &type, input))
	{
		addKeyword(table, type, input);
	}
	fclose(fp);

	// Initialise the Grammer
	Grammar G = (Grammar)malloc(RULECNT*sizeof(gHead));
	G = createGrammar();
	findFirst(G);
	findFollow(G);
	createParseTable(G);

	while(1)
	{
		//Display the menu
		printf("\nERPLAG COMPILER MENU OPTIONS:\n");
		printf("1: For printing the token list generated by the lexer.\n");
		printf("2: For parsing the input sorce code and creating the parsetree.\n");
		printf("3: For printing the Abstract Syntax Tree of the code.\n");
		printf("4: For printing the size of parsetree and Abstract Syntax Tree.\n");
		printf("5: For printing the Symbol table.\n");
		printf("6: For checking the syntactic and semantic analysis of the code.\n");
		printf("7: For generating the assembly code in the NASM format.\n");
		printf("8: Quit.\n");
		int option;
		scanf("%d",&option);

		printSep();
		if(option == 1)
		{
			int error_exist = populateLexemeTable(argv[1], table, 1);
			if (error_exist == 1)
			{
				printf("Recheck your code for Lexical errors\n");
			}
		}
		else if(option == 2)
		{
			removeComments(argv[1], "clean.txt");
			printParseTree("clean.txt", table, G);
			printf("\n");
		}
		else if(option == 3)
		{
			removeComments(argv[1], "clean.txt");
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			if (parse_status == 1)
			{
				tokenInfo *T = getFirstToken();
				hashTable2 tableId = initializeHashTable2(hash_capacity_2);
				hashTable2 tableFunc = initializeHashTable2(hash_capacity_2);
				totalScopeList* scopeTable = (totalScopeList *)malloc(LIMIT * sizeof(totalScopeList));
				int i;
				for(i = 0; i < LIMIT; ++i)
				{
					scopeTable[i].scope_start = 0;
					scopeTable[i].scope_end = 0;
				}
				createIDTable(T, scopeTable, tableId, tableFunc, 0);
				T = getFirstToken();
				secondRun(T, tableId, tableFunc, 0);
				printf("AST was successfully generated and printed in pre-order traversal (Parent, left child and then rest of child in linklist)\n");
				printf("\n");
				ASTree _ast = buildASTree(Tree, tableId, tableFunc, 1);
			}
		}
		else if (option == 4)
		{
			removeComments(argv[1], "clean.txt");
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			if (parse_status == 1)
			{
				tokenInfo *T = getFirstToken();
				hashTable2 tableId = initializeHashTable2(hash_capacity_2);
				hashTable2 tableFunc = initializeHashTable2(hash_capacity_2);
				totalScopeList* scopeTable = (totalScopeList *)malloc(LIMIT * sizeof(totalScopeList));
				int i;
				for(i = 0; i < LIMIT; ++i)
				{
					scopeTable[i].scope_start = 0;
					scopeTable[i].scope_end = 0;
				}
				createIDTable(T, scopeTable, tableId, tableFunc, 0);
				T = getFirstToken();
				secondRun(T, tableId, tableFunc, 0);
				ASTree _ast = buildASTree(Tree, tableId, tableFunc, 0);
				int parse_tree_bytes = (int)sizeof(struct pNode) * no_of_parse_tree_nodes;
				printf("Number of Parse Tree Nodes : %d, Memory used by Parse Tree Nodes: %d bytes\n", no_of_parse_tree_nodes, parse_tree_bytes);
				int ast_tree_bytes = (int)sizeof(struct ASTNode) * no_of_ast_tree_nodes;
				printf("Number of Abstract Syntax Tree Nodes : %d, Memory used by Abstract Syntax Tree Nodes: %d bytes\n", no_of_ast_tree_nodes, ast_tree_bytes);
				printf("Compression ratio : %lf\n", (((double)parse_tree_bytes - ast_tree_bytes)/parse_tree_bytes)*100.0);
			}
		}
		else if (option == 5)
		{
			removeComments(argv[1], "clean.txt");
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			if (parse_status == 1) 
			{
				tokenInfo *T = getFirstToken();
				hashTable2 tableId = initializeHashTable2(hash_capacity_2);
				hashTable2 tableFunc = initializeHashTable2(hash_capacity_2);
				totalScopeList* scopeTable = (totalScopeList *)malloc(LIMIT * sizeof(totalScopeList));
				int i;
				for(i = 0; i < LIMIT; ++i)
				{
					scopeTable[i].scope_start = 0;
					scopeTable[i].scope_end = 0;
				}
				createIDTable(T, scopeTable, tableId, tableFunc, 0);
				T = getFirstToken();
				secondRun(T, tableId, tableFunc, 0);
				printf("Symbol Table sucessfully created.\n");
				printf("%-4s %-10s\t%-20s %-10s %-15s %-6s %-6s %-6s\n", "SNO", "Var-Name", "Func-Name", "Datatype", "Start - End", "Level", "Size", "Offset");
				printVariables(tableId, scopeTable);
			}
			else
			{
				printf("Parsing was not successful. So symbol table is not created.\n");
			}
		}
		else if (option == 6 || option == 7)
		{
			removeComments(argv[1], "clean.txt");
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			if (parse_status == 1) 
			{
				tokenInfo *T = getFirstToken();
				hashTable2 tableId = initializeHashTable2(hash_capacity_2);
				hashTable2 tableFunc = initializeHashTable2(hash_capacity_2);
				totalScopeList* scopeTable = (totalScopeList *)malloc(LIMIT * sizeof(totalScopeList));
				int i;
				for(i = 0; i < LIMIT; ++i)
				{
					scopeTable[i].scope_start = 0;
					scopeTable[i].scope_end = 0;
				}
				semantic_status = 1;
				createIDTable(T, scopeTable, tableId, tableFunc, 1);
				T = getFirstToken();
				secondRun(T, tableId, tableFunc, 1);
				ASTree _ast = buildASTree(Tree, tableId, tableFunc, 0);
				int type_error = ASTQueueTypeChecker(_ast.root, 0);
				type_error = ASTQueueTypeChecker(_ast.root, 1);
				if (semantic_status == 1 && type_error == 0)
				{
					printf("No sematic errors were found.\n");
					if (option == 7)
					{
						//assembly code generation logic
					}
				}
				else
				{
					if (option == 7)
					{
						printf("Assembly code can't be generated due to semantic errors existing in code.\n");
					}
				}
			}
			else
			{
				printf("Parsing was not successful. So no semantic erros are detected.\n");
				if (option == 7)
				{
					printf("Assembly code can't be generated.\n");
				}
			}
		}
		else if (option == 8)
		{
			break;
		}
		else
		{
			printf("\nInvalid Option\n");
		}
		printSep();
	}
	return(0);	
}

void printSep() 
{
	printf("\n****************************************************************************************************\n");
}
